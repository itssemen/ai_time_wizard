import json
import random
# from faker import Faker # Faker не используется, можно будет удалить, если не понадобится в будущем
# from datetime import datetime, timedelta # datetime не используется

# fake = Faker('ru_RU') # Faker не используется

# --- Расширенные параметры для генерации ---

# Категории задач и примерные действия с типичными длительностями (min, max) в минутах
TASK_CATEGORIES = {
    "короткие_коммуникации": {
        "actions": [
            "позвонить {кому}", "написать сообщение {кому} по {вопросу_коммуникации}", "ответить на письмо {от кого}",
            "скинуть файл {кому}", "уточнить детали по {чему}", "согласовать {что} с {кем}",
            "проверить почту", "быстро ответить {кому}", "написать {кому} короткое письмо",
            "переслать информацию {кому} от {кого}"
        ],
        "duration_range": (5, 30), # немного расширим
        "keywords_for_duration": {"позвонить": (5,20), "написать": (5,25), "проверить почту": (5,15), "согласовать": (10,30)}
    },
    "быт_еда": {
        "actions": [
            "приготовить {что_еда}", "заказать {что_еда_заказ}", "помыть посуду", "загрузить стирку",
            "развесить белье", "полить цветы", "вынести мусор", "сходить в магазин за {чем_покупки}",
            "купить продукты", "прибраться на кухне", "протереть стол"
        ],
        "duration_range": (10, 90), # расширим
        "keywords_for_duration": {"приготовить": (25,90), "сходить в магазин": (20,75), "заказать": (5,15)}
    },
    "уборка_организация": {
        "actions": [
            "сделать уборку в {где_дом}", "пропылесосить {где_дом}", "вытереть пыль", "разобрать {что_разбор}",
            "навести порядок на столе", "организовать файлы на {носителе_информации}", "рассортировать документы",
            "помыть пол в {где_дом}", "почистить {что_чистка}"
        ],
        "duration_range": (20, 150), # расширим
        "keywords_for_duration": {"сделать уборку": (40,180), "разобрать": (30,120), "организовать файлы": (20,90)}
    },
    "работа_проекты": {
        "actions": [
            "поработать над проектом {каким_проект}", "написать код для {чего_программирование}", "отладить {что_программирование}",
            "подготовить отчет по {теме_отчета}", "составить план {чего_планирование}", "провести исследование {темы_исследования}",
            "проанализировать данные {какие_данные}", "написать статью о {чем_статья}", "решить рабочую задачу {какую_задачу}",
            "провести ревью кода {чьего_кода}", "обновить документацию по {системе}", "подготовить презентацию {тема_презентации}"
        ],
        "duration_range": (30, 300), # расширим
        "keywords_for_duration": {"отчет": (60,300), "исследование": (90,360), "код": (45,240), "презентац": (60,240)}
    },
    "встречи_созвоны": {
        "actions": [
            "провести встречу с {кем_встреча}", "созвониться с {кем_встреча} по {вопросу_созвона}", "участвовать в совещании {тема_совещания}",
            "обсудить {что_обсуждение} с командой", "планерка по {проекту_планерки}", "стендап", "daily митинг",
            "провести one-on-one с {кем}"
        ],
        "duration_range": (15, 120), # немного изменим
        "keywords_for_duration": {"совещание": (30,120), "планерка": (15,60), "one-on-one": (30,60)}
    },
    "обучение_развитие": {
        "actions": [
            "изучить {что_изучение}", "пройти онлайн-курс по {теме_курса}", "посмотреть вебинар о {чем_вебинар}",
            "почитать профессиональную литературу {какую_книгу}", "сделать упражнения по {предмету_упражнения}", "выучить новые слова на {языке_изучения}",
            "попрактиковаться в {навыке}", "посмотреть лекцию по {теме_лекции}"
        ],
        "duration_range": (30, 240), # расширим
        "keywords_for_duration": {"изучить": (40,150), "курс": (60,240), "лекцию": (45,120)}
    },
    "личные_дела_поручения": {
        "actions": [
            "записаться к {специалисту}", "оплатить {что_счета}", "сходить в {место_посещения}", "забрать {что_забрать} из {откуда_забрать}",
            "починить {что_ремонт}", "купить билеты на {событие}", "подать документы в {организацию}", "поздравить {кого} с {праздником}",
            "отвезти {что_отвезти} в {место_назначения}", "посетить {мероприятие_личного_характера}"
        ],
        "duration_range": (10, 120), # расширим
        "keywords_for_duration": {"записаться": (5,30), "оплатить счета": (10,40), "подать документы": (30,90)}
    },
    "отдых_хобби": {
        "actions": [
            "почитать книгу {какую_книгу_отдых}", "посмотреть фильм {какой_фильм}", "послушать {что_музыка}", "поиграть в {какую_игру}",
            "заняться хобби ({каким_хобби})", "погулять {где_прогулка}", "помедитировать", "поспать {сколько_сон} часов", "отдохнуть немного",
            "порисовать {что_рисование}", "поиграть на {муз_инструменте}"
        ],
        "duration_range": (20, 240), # расширим
        "keywords_for_duration": {"посмотреть фильм": (75,180), "погулять": (30,120), "поспать": (300, 600), "почитать книгу": (30,120)}
    },
    "спорт_здоровье": {
        "actions": [
            "сделать зарядку", "пойти на тренировку в {место_тренировки}", "пробежка на {дистанцию_бег}", "заняться йогой",
            "посетить врача {специалист_врач}", "принять лекарства", "сделать упражнения для {части_тела}", "поплавать в бассейне"
        ],
        "duration_range": (15, 150), # расширим
        "keywords_for_duration": {"тренировка": (40,100), "пробежка": (25,90), "врача": (30,90)}
    },
    "творчество_создание": {
        "actions": [
            "написать {что_текст}", "сочинить {что_музыкальное}", "сделать {что_рукоделие} своими руками",
            "записать видео о {теме_видео}", "разработать дизайн для {чего_дизайн}", "придумать идею для {проекта_идея}"
        ],
        "duration_range": (45, 300),
        "keywords_for_duration": {"написать текст": (60,240), "дизайн": (90,300), "видео": (120,360)}
    },
    "планирование_анализ_будущего": {
        "actions": [
            "спланировать {что_план_будущее}", "проанализировать {что_анализ_будущее}", "подумать над {вопросом_размышления}",
            "поставить цели на {период}", "обдумать стратегию {чего_стратегия}"
        ],
        "duration_range": (20, 120),
        "keywords_for_duration": {"спланировать": (30,90), "проанализировать": (45,120)}
    }
}

# Заполнители для действий
PLACEHOLDERS = {
    "кому": ["маме", "другу", "коллеге", "начальнику", "клиенту", "подруге", "брату", "партнеру", "поставщику"],
    "от кого": ["банка", "партнера", "руководства", "клиента", "коллеги", "друга"],
    "что": ["этот вопрос", "детали проекта", "план работ", "условия договора", "презентацию", "ужин", "отчет", "концепцию"],
    "чем_покупки": ["хлебом", "молоком", "овощами", "фруктами", "необходимым", "бытовой химией", "канцтоварами"],
    "где_дом": ["комнате", "квартире", "на кухне", "в гостиной", "в ванной", "на балконе"],
    "каким_проект": ["новым", "интересным", "сложным", "важным", "текущим", "личным", "рабочим"],
    "чего_программирование": ["новой фичи", "багфикса", "модуля", "скрипта", "интеграции"],
    "что_программирование": ["программу", "скрипт", "алгоритм", "функцию"],
    "теме_отчета": ["продаж", "нового продукта", "анализа конкурентов", "квартального отчета", "маркетинговой кампании"],
    "чего_планирование": ["следующей недели", "маркетинговой кампании", "разработки фичи", "отпуска", "бюджета"],
    "темы_исследования": ["рынка", "пользовательского поведения", "новых технологий", "эффективности процесса"],
    "какие_данные": ["финансовые", "статистические", "пользовательские", "операционные", "маркетинговые"],
    "чем_статья": ["искусственном интеллекте", "путешествиях", "здоровом питании", "новой технологии"],
    "какую_задачу": ["сложную", "срочную", "аналитическую", "техническую", "креативную"],
    "кем_встреча": ["командой", "клиентом", "руководителем", "партнерами", "кандидатом"],
    "вопросу_созвона": ["сотрудничества", "поставки", "текущих задач", "обновлений", "фидбека"],
    "тема_совещания": ["по итогам квартала", "по новому проекту", "о стратегии развития", "по проблемам в отделе"],
    "что_обсуждение": ["результаты спринта", "планы на следующий месяц", "возникшие проблемы", "новые идеи"],
    "проекту_планерки": ["Alpha", "Omega", "развития платформы", "запуска продукта"],
    "что_изучение": ["новый фреймворк", "иностранный язык", "технику быстрого чтения", "основы дизайна"],
    "теме_курса": ["Python-разработки", "маркетинга в соцсетях", "управления проектами", "финансовой грамотности"],
    "чем_вебинар": ["трендах в IT", "личной эффективности", "инвестициях", "копирайтинге"],
    "какую_книгу": ["по специальности", "художественную", "научно-популярную"],
    "предмету_упражнения": ["английскому языку", "программированию", "математике", "физике"],
    "языке_изучения": ["английском", "немецком", "испанском", "китайском", "французском"],
    "специалисту": ["врачу", "стоматологу", "парикмахеру", "юристу", "бухгалтеру"],
    "что_счета": ["коммунальные услуги", "интернет", "мобильную связь", "кредит"],
    "место_посещения": ["банк", "почту", "химчистку", "спортзал", "бассейн", "МФЦ", "музей"],
    "что_забрать": ["посылку", "документы", "заказ", "одежду из химчистки"],
    "откуда_забрать": ["ремонта", "прачечной", "пункта выдачи", "работы", "школы"],
    "что_ремонт": ["кран", "велосипед", "компьютер", "полку"],
    "событие": ["концерт", "спектакль", "футбольный матч", "самолет", "поезд"],
    "организацию": ["налоговую", "университет", "визовый центр", "банк"],
    "праздником": ["днем рождения", "юбилеем", "Новым Годом", "профессиональным праздником"],
    "какую_книгу_отдых": ["детектив", "фантастику", "классику", "любовный роман"],
    "какой_фильм": ["новый", "документальный", "любимый", "комедию", "драму"],
    "что_музыка": ["любимую музыку", "подкаст", "аудиокнигу", "новый альбом"],
    "какую_игру": ["компьютерную игру", "настолку", "шахматы", "головоломку"],
    "каким_хобби": ["вязанием", "моделированием", "фотографией", "садоводством"],
    "где_прогулка": ["в парке", "в лесу", "по городу", "вдоль набережной"],
    "сколько_сон": ["7", "8", "немного", "час", "полтора"],
    "место_тренировки": ["спортзал", "стадион", "парк", "дом"],
    "дистанцию_бег": ["5 км", "короткую дистанцию", "обычную дистанцию", "10 км", "интервальную"],
    "специалист_врач": ["терапевту", "окулисту", "кардиологу", "неврологу"],
    "вопросу_коммуникации": ["проекту", "договору", "встрече", "отчету", "доставке"],
    "что_еда": ["завтрак", "обед", "ужин", "пирог", "салат", "суп"],
    "что_еда_заказ": ["пиццу", "суши", "готовую еду из ресторана", "продукты на дом"],
    "что_разбор": ["вещи в шкафу", "старые бумаги", "фотографии", "инструменты"],
    "носителе_информации": ["компьютере", "внешнем диске", "облаке", "флешке"],
    "что_чистка": ["раковину", "плиту", "микроволновку", "ковер"],
    "чьего_кода": ["коллеги", "джуниора", "своего старого"],
    "системе": ["CRM", "базе данных", "API", "внутреннему порталу"],
    "тема_презентации": ["для клиента", "для команды", "по результатам проекта", "о новом продукте"],
    "навыке": ["слепой печати", "публичных выступлений", "быстрого счета", "рисования"],
    "теме_лекции": ["истории искусств", "квантовой физике", "нейросетям", "экономике"],
    "что_отвезти": ["документы", "подарок", "вещи", "заказ"],
    "место_назначения": ["офис", "другу", "на дачу", "в сервис"],
    "мероприятие_личного_характера": ["выставку", "родительское собрание", "встречу выпускников"],
    "что_рисование": ["пейзаж", "натюрморт", "портрет", "абстракцию"],
    "муз_инструменте": ["гитаре", "пианино", "скрипке", "барабанах"],
    "части_тела": ["спины", "пресса", "ног", "рук"],
    "что_текст": ["статью для блога", "рассказ", "стихотворение", "пост для соцсетей"],
    "что_музыкальное": ["песню", "мелодию", "аранжировку"],
    "что_рукоделие": ["шарф", "игрушку", "картину", "украшение"],
    "теме_видео": ["обзоре продукта", "путешествии", "обучающем материале"],
    "чего_дизайн": ["сайта", "логотипа", "интерьера", "приложения"],
    "проекта_идея": ["стартапа", "нового продукта", "улучшения процесса", "творческого проекта"],
    "что_план_будущее": ["карьеру", "путешествие", "покупку", "обучение"],
    "что_анализ_будущее": ["свои финансы", "прошлые ошибки", "возможности для роста", "риски"],
    "вопросом_размышления": ["смысле жизни", "будущем", "принятии решения", "своих целях"],
    "период": ["неделю", "месяц", "квартал", "год", "пятилетку"],
    "чего_стратегия": ["развития бизнеса", "личного бренда", "инвестирования", "достижения цели"]
}


HIGH_PRIORITY_KEYWORDS = ["срочно", "важно", "немедленно", "в первую очередь", "обязательно", "критично", "дедлайн", "горит", "кровь из носу"]
LOW_PRIORITY_KEYWORDS = ["если будет время", "потом", "не горит", "можно отложить", "второстепенно", "когда-нибудь", "не к спеху", "по возможности"]

def get_realistic_duration(action_text_template, action_text_concrete):
    action_text_lower = action_text_concrete.lower()

    # Сначала ищем по ключевым словам в конкретной фразе, если они есть в категории
    for category_name, cat_data in TASK_CATEGORIES.items():
        if action_text_template in cat_data["actions"]: # Проверяем, что шаблон из этой категории
            for keyword, (dur_min, dur_max) in cat_data.get("keywords_for_duration", {}).items():
                if keyword in action_text_lower:
                    return random.randint(dur_min // 5, dur_max // 5) * 5 # Возвращаем с шагом 5 минут
            # Если специфичных ключевых слов не найдено, используем общий диапазон категории
            cat_min, cat_max = cat_data["duration_range"]
            return random.randint(cat_min // 5, cat_max // 5) * 5

    # Общий дефолт, если категория не найдена (маловероятно при текущей логике)
    return random.choice([30, 45, 60, 90])


def determine_priority(action_text_template, action_text_concrete, explicit_priority_phrase=None):
    action_text_concrete_lower = action_text_concrete.lower()
    # high: 2, medium: 1, low: 0
    if explicit_priority_phrase:
        phrase_lower = explicit_priority_phrase.lower()
        if any(k in phrase_lower for k in HIGH_PRIORITY_KEYWORDS):
            return 2 # high
        if any(k in phrase_lower for k in LOW_PRIORITY_KEYWORDS):
            return 0 # low

    if any(k in action_text_concrete_lower for k in HIGH_PRIORITY_KEYWORDS):
        return 2 # high
    if any(k in action_text_concrete_lower for k in LOW_PRIORITY_KEYWORDS):
        return 0 # low
    
    # Эвристики на основе категории задачи, если нет явных ключевых слов
    # (можно добавить, если TASK_CATEGORIES будут содержать информацию о типичном приоритете)
    # Например, задачи из "работа_проекты" могут чаще быть high/medium
    # Задачи из "отдых_хобби" чаще low/medium

    # Пример простой логики на основе содержания задачи (можно оставить или улучшить)
    if any(kw in action_text_concrete_lower for kw in ["отчет", "презентац", "документ", "дедлайн", "срочная задача"]):
        return 2 # high
    if any(kw in action_text_concrete_lower for kw in ["посмотреть фильм", "почитать книгу", "погулять", "отдохнуть", "хобби"]):
        return 0 # low
    return 1 # medium


def generate_task_item():
    # Выбираем случайную категорию и из нее случайный шаблон действия
    chosen_category_name = random.choice(list(TASK_CATEGORIES.keys()))
    chosen_category = TASK_CATEGORIES[chosen_category_name]
    action_template = random.choice(chosen_category["actions"])

    # Заполняем плейсхолдеры в шаблоне действия
    action_text_concrete = action_template
    # Ищем все плейсхолдеры вида {key}
    placeholders_in_template = [ph[1:-1] for ph in action_template.split() if ph.startswith("{") and ph.endswith("}")]

    filled_placeholders = {}
    for ph_key in placeholders_in_template:
        if ph_key in PLACEHOLDERS:
            chosen_value = random.choice(PLACEHOLDERS[ph_key])
            action_text_concrete = action_text_concrete.replace("{" + ph_key + "}", chosen_value, 1)
            filled_placeholders[ph_key] = chosen_value

    # Временные указания и соответствующие минуты
    # Расширенный список, включающий более разнообразные и числовые варианты
    time_options = [
        ("часик", 60), ("пару часов", 120), ("полчаса", 30), ("часа полтора", 90), ("полтора часа", 90),
        ("два часа", 120), ("три часа", 180), ("четыре часа", 240), ("пять часов", 300),
        ("минут 5", 5), ("минут 10", 10), ("минут 15", 15), ("минут 20", 20), ("минут 25", 25),
        ("минут 30", 30), ("минут 40", 40), ("минут 45", 45), ("минут 50", 50), ("минут 55", 55),
        ("1 час", 60), ("2 часа", 120), ("3 часа", 180), ("4 часа", 240),
        ("1.5 часа", 90), ("2.5 часа", 150), ("0.5 часа", 30),
        ("1ч", 60), ("2ч", 120), ("1ч30м", 90), ("45м", 45), ("90 мин", 90), ("15 мин", 15), ("120 минут", 120),
        ("на полчасика", 30), ("на часок-другой", random.choice([60, 90, 120, 150])),
        ("немного времени на", random.choice([15, 20, 30, 40])),
        ("посвятить этому где-то", random.choice([45, 60, 75, 90, 100, 120])),
        ("буквально {N} минут", None), # Динамическое значение N
        ("около {N} часов", None), # Динамическое значение N
        ("", None) # Вариант без явного указания времени (будет использован get_realistic_duration)
    ]
    
    # Вероятность явного указания времени (например, 75%)
    if random.random() < 0.75:
        duration_phrase_template, duration_minutes_from_phrase = random.choice(time_options)

        # Обработка динамических фраз
        if "{N}" in duration_phrase_template:
            if "минут" in duration_phrase_template:
                n_val = random.choice([5, 10, 15, 20, 25, 30, 40, 50])
                actual_duration_minutes = n_val
                duration_phrase = duration_phrase_template.format(N=n_val)
            elif "часов" in duration_phrase_template:
                n_val = random.choice([1, 2, 3, 1.5, 2.5])
                actual_duration_minutes = int(n_val * 60)
                duration_phrase = duration_phrase_template.format(N=n_val)
            else: # на всякий случай, если шаблон другой
                actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)
                duration_phrase = ""
        elif duration_minutes_from_phrase is None: # Если выбран вариант "без явного указания времени"
            actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)
            duration_phrase = "" # Убедимся, что фраза пустая
        else:
            actual_duration_minutes = duration_minutes_from_phrase
            duration_phrase = duration_phrase_template
            # Небольшая вариативность для фраз типа "часик", "пару часов"
            if duration_phrase_template in ["часик", "пару часов", "на часок-другой"]:
                 actual_duration_minutes = random.randint(max(15, actual_duration_minutes - 20) // 5, (actual_duration_minutes + 20) // 5) * 5
    else:
        duration_phrase = ""
        actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)

    # Фразы приоритета
    priority_phrases = ["", "это очень важно", "нужно сделать срочно", "это не горит", "можно сделать потом",
                        "обязательно выполни", "критически важно", "если останется время", "первостепенно",
                        "не к спеху", "сделай как можно скорее", "постарайся успеть", "второстепенная задача",
                        "это прям горит", "подождет до завтра"]

    # Вероятность явного указания приоритета фразой (например, 40%)
    explicit_priority_phrase = ""
    if random.random() < 0.4:
        explicit_priority_phrase = random.choice(priority_phrases)

    priority = determine_priority(action_template, action_text_concrete, explicit_priority_phrase)

    # Убедимся, что текст задачи не пустой, если плейсхолдеры не заполнились (маловероятно)
    if not action_text_concrete.strip():
        action_text_concrete = "какое-то дело" # Запасной вариант

    return action_text_concrete, duration_phrase, actual_duration_minutes, priority, explicit_priority_phrase


def generate_freeform_sentence():
    starters = [
        "Сегодня мне нужно", "Мой план на день:", "Надо не забыть", "Запланировал себе",
        "Вот что я должен сделать:", "Задачи на сегодня:", "Хочу успеть", "Собираюсь сделать",
        "Мои дела:", "Планы:", "Необходимо выполнить:", "Список дел:", "Так, поехали:",
        "На повестке дня:", "Сегодня в программе:", "Первым делом,"
    ]
    
    # Шаблоны для сборки предложения с задачей
    # {action} - сама задача
    # {duration_phrase} - фраза о времени, например "полчаса"
    # {priority_phrase} - фраза о приоритете, например "это очень важно"
    sentence_templates = [
        "{action} {duration_phrase} {priority_phrase}",
        "{action} {priority_phrase} {duration_phrase}",
        "{priority_phrase}, {action} {duration_phrase}",
        "{action} {duration_phrase}",
        "{action} {priority_phrase}",
        "{action}",
        "{duration_phrase} на {action} {priority_phrase}",
        "{duration_phrase} хочу потратить на {action}",
        "Займусь {action} {duration_phrase}",
        "Нужно {action}", "Надо бы {action}",
        "Обязательно {action} {duration_phrase}",
        "Не забыть: {action}",
        "Потом можно {action}",
        "Если успею, то {action} {duration_phrase}",
        "В планах также {action}",
        "Кстати, еще {action} {priority_phrase}",
        "И {action} {duration_phrase} {priority_phrase}." # Добавил точку для разнообразия
    ]
    
    full_text = random.choice(starters) + " "
    num_tasks = random.randint(1, 6) # Увеличим максимальное число задач до 6
    entities = []
    current_pos = len(full_text)

    for i in range(num_tasks):
        action_text_concrete, duration_ph, duration_min, task_priority, priority_ph = generate_task_item()
        
        # Выбираем шаблон для текущей задачи
        template = random.choice(sentence_templates)
        
        # Подготавливаем части для форматирования
        format_args = {
            "action": action_text_concrete, # Используем конкретный текст задачи
            "duration_phrase": duration_ph.strip(),
            "priority_phrase": priority_ph.strip()
        }
        
        # Собираем полный текст текущего элемента списка дел
        # Убираем лишние пробелы, которые могли возникнуть из-за пустых фраз
        current_task_full_phrase = template.format(**format_args)
        current_task_full_phrase = ' '.join(filter(None, current_task_full_phrase.split(' ')))
        current_task_full_phrase = current_task_full_phrase.replace(" ,", ",").replace(" .", ".") # Чистим пунктуацию
        
        # Добавляем в общий текст
        full_text += current_task_full_phrase

        # Определяем start/end для action_text_concrete
        # Ищем action_text_concrete в только что добавленном current_task_full_phrase
        action_start_in_segment = -1
        # Пробуем найти точное совпадение сначала
        # Для более надежного поиска можно использовать fuzzy matching или учитывать возможные вариации из-за форматирования
        # но для генерации, где мы контролируем процесс, это должно работать нормально.

        # Чтобы поиск был точнее, мы ищем action_text_concrete в последнем добавленном сегменте (current_task_full_phrase)
        # и затем смещаем на current_pos.
        # Однако, если action_text_concrete сам является результатом форматирования (например, содержит duration_phrase),
        # то лучше искать его "как есть".

        # Ищем action_text_concrete в full_text, начиная с current_pos.
        # Это более надежно, если action_text_concrete не содержит других фраз.
        # Если action_text_concrete может содержать duration_phrase или priority_phrase (из-за шаблона),
        # то нужно извлекать "чистую" задачу. Для простоты, сейчас считаем, что action_text_concrete - это и есть задача.

        search_text_lower = full_text[current_pos:].lower()
        action_to_find_lower = action_text_concrete.lower()

        action_start_in_segment = search_text_lower.find(action_to_find_lower)

        if action_start_in_segment != -1:
            action_start_global = current_pos + action_start_in_segment
            action_end_global = action_start_global + len(action_text_concrete) # Длина оригинального, не lower-case

            # Проверка на пересечение с предыдущими сущностями (простой вариант)
            valid_entity = True
            for prev_entity in entities:
                if max(prev_entity['start'], action_start_global) < min(prev_entity['end'], action_end_global):
                    valid_entity = False
                    # print(f"Warning: Overlapping entity found for '{action_text_concrete}'. Skipping.") # Для отладки
                    break

            if valid_entity:
                entities.append({
                    "text": action_text_concrete, # Текст самой задачи
                    "start": action_start_global,
                    "end": action_end_global,
                    "label": "TASK",
                    "priority": task_priority,
                    "duration_minutes": duration_min,
                    "duration_phrase_original": duration_ph
                })

        current_pos += len(current_task_full_phrase)

        # Добавление разделителей
        if i < num_tasks - 1:
            # Добавляем больше вариаций разделителей и опционально точку перед следующим элементом
            if random.random() < 0.2 and not full_text.strip().endswith((".", "!", "?", ";", ",")):
                full_text += random.choice([". ", "! ", "? "]) # Завершаем предыдущее "предложение"
                current_pos += 2
                # Иногда начинаем следующее "предложение" с заглавной буквы (имитация)
                # Это не меняет сами токены, но может влиять на контекст для NER
                if random.random() < 0.5:
                     current_task_full_phrase = current_task_full_phrase[0].upper() + current_task_full_phrase[1:]

            sep = random.choice([", ", "; ", ". Потом ", ". А еще ", " и ", ". Затем ", ". После этого ",
                                 ", также ", ", кроме того ", ". Далее, ", " плюс к этому "])
            full_text += sep
            current_pos += len(sep)
        else:
            # Убедимся, что в конце есть знак препинания, если его еще нет
            if not full_text.strip().endswith((".", "!", "?")):
                 full_text += random.choice([".", "!"])
                 current_pos += 1
            elif full_text.strip().endswith((",", ";")): # Заменяем висящие запятые/точки с запятой
                full_text = full_text.strip()[:-1] + random.choice([".", "!"])


    # Финальная очистка текста (убрать лишние пробелы по краям, двойные пробелы, пробелы перед знаками препинания)
    full_text = ' '.join(full_text.split())
    full_text = full_text.replace(" .", ".").replace(" ,", ",").replace(" !", "!").replace(" ?", "?")
    full_text = full_text.replace(" ;", ";")


    return {
        "text": full_text,
        "entities": entities # Отдаем только непересекающиеся сущности
    }

# Генерация датасета
NUM_EXAMPLES = 1500 # Увеличено количество примеров до 1500
dataset = []
generated_count = 0
attempt_limit = NUM_EXAMPLES * 3 # Увеличим лимит попыток, т.к. генерация может быть сложнее

while generated_count < NUM_EXAMPLES and attempt_limit > 0:
    example = generate_freeform_sentence()
    # Проверяем, что есть хотя бы одна сущность, чтобы избежать пустых примеров
    # и что текст не слишком короткий (например, минимум 10 символов)
    if example["entities"] and len(example["text"]) > 10 :
        dataset.append(example)
        generated_count += 1
    attempt_limit -=1

if attempt_limit <= 0:
    print(f"Предупреждение: Достигнут лимит попыток генерации. Сгенерировано {generated_count} из {NUM_EXAMPLES} примеров.")
elif generated_count < NUM_EXAMPLES:
    print(f"Предупреждение: Сгенерировано только {generated_count} из {NUM_EXAMPLES} запрошенных примеров (достигнут лимит попыток или другие причины).")


# Сохранение
output_file_path = 'ml/freeform_task_dataset.json'
with open(output_file_path, 'w', encoding='utf-8') as f:
    json.dump(dataset, f, ensure_ascii=False, indent=2)

print(f"Создан датасет ({len(dataset)} примеров) и сохранен в '{output_file_path}'.")

# Пример вывода одного элемента
if dataset:
    print("\nПример сгенерированного элемента:")
    print(json.dumps(dataset[0], ensure_ascii=False, indent=2))
