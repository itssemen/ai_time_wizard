import json
import random
# from faker import Faker # Faker не используется, можно будет удалить, если не понадобится в будущем
# from datetime import datetime, timedelta # datetime не используется

# fake = Faker('ru_RU') # Faker не используется

# --- Расширенные параметры для генерации ---

# Дополнительные глаголы и контексты для разнообразия
ADDITIONAL_ACTIONS_CONTEXTS = {
    "глаголы_общего_назначения": [
        "проверить", "подготовить", "организовать", "обновить", "завершить", "начать", "продолжить",
        "изучить", "проанализировать", "создать", "настроить", "протестировать", "задокументировать",
        "обсудить", "согласовать", "пересмотреть", "оптимизировать", "исправить", "найти", "выбрать",
        "загрузить", "скачать", "установить", "удалить", "настроить", "сохранить", "отправить", "получить"
    ],
    "объекты_действий_разные": [
        "отчет", "презентацию", "документы", "код", "дизайн", "контент", "план", "бюджет", "список задач",
        "электронную почту", "календарь", "базу данных", "сервер", "приложение", "веб-сайт", "систему",
        "конфигурацию", "материалы", "исследование", "аналитику", "метрики", "результаты", "ошибки",
        "билеты", "бронь", "заказ", "посылку", "доставку", "ремонт", "уборку", "покупки", "счета"
    ],
    "контексты_места_инструменты": [
        "в Jira", "в Confluence", "в Trello", "в Asana", "в Figma", "в Photoshop", "в VS Code", "в Excel",
        "в Google Docs", "на GitHub", "в CRM", "в ERP", "по электронной почте", "в Slack", "в Zoom",
        "на совещании", "на встрече с клиентом", "для проекта X", "по задаче Y", "в рамках спринта Z",
        "на компьютере", "на ноутбуке", "на телефоне", "в офисе", "дома", "в коворкинге", "в дороге"
    ]
}

# Категории задач и примерные действия с типичными длительностями (min, max) в минутах
TASK_CATEGORIES = {
    "короткие_коммуникации": {
        "actions": [
            "позвонить {кому}", "написать сообщение {кому} по {вопросу_коммуникации}", "ответить на письмо {от кого}",
            "скинуть файл {кому}", "уточнить детали по {чему}", "согласовать {что} с {кем}",
            "проверить почту", "быстро ответить {кому}", "написать {кому} короткое письмо",
            "переслать информацию {кому} от {кого}"
        ],
        "duration_range": (5, 30), # немного расширим
        "keywords_for_duration": {"позвонить": (5,20), "написать": (5,25), "проверить почту": (5,15), "согласовать": (10,30)}
    },
    "быт_еда": {
        "actions": [
            "приготовить {что_еда}", "заказать {что_еда_заказ}", "помыть посуду", "загрузить стирку",
            "развесить белье", "полить цветы", "вынести мусор", "сходить в магазин за {чем_покупки}",
            "купить продукты", "прибраться на кухне", "протереть стол"
        ],
        "duration_range": (10, 90), # расширим
        "keywords_for_duration": {"приготовить": (25,90), "сходить в магазин": (20,75), "заказать": (5,15)}
    },
    "уборка_организация": {
        "actions": [
            "сделать уборку в {где_дом}", "пропылесосить {где_дом}", "вытереть пыль", "разобрать {что_разбор}",
            "навести порядок на столе", "организовать файлы на {носителе_информации}", "рассортировать документы",
            "помыть пол в {где_дом}", "почистить {что_чистка}"
        ],
        "duration_range": (20, 150), # расширим
        "keywords_for_duration": {"сделать уборку": (40,180), "разобрать": (30,120), "организовать файлы": (20,90)}
    },
    "работа_проекты": {
        "actions": [
            "поработать над проектом {каким_проект}", "написать код для {чего_программирование}", "отладить {что_программирование}",
            "подготовить отчет по {теме_отчета}", "составить план {чего_планирование}", "провести исследование {темы_исследования}",
            "проанализировать данные {какие_данные}", "написать статью о {чем_статья}", "решить рабочую задачу {какую_задачу}",
            "провести ревью кода {чьего_кода}", "обновить документацию по {системе}", "подготовить презентацию {тема_презентации}"
        ],
        "duration_range": (30, 300), # расширим
        "keywords_for_duration": {"отчет": (60,300), "исследование": (90,360), "код": (45,240), "презентац": (60,240)}
    },
    "встречи_созвоны": {
        "actions": [
            "провести встречу с {кем_встреча}", "созвониться с {кем_встреча} по {вопросу_созвона}", "участвовать в совещании {тема_совещания}",
            "обсудить {что_обсуждение} с командой", "планерка по {проекту_планерки}", "стендап", "daily митинг",
            "провести one-on-one с {кем}"
        ],
        "duration_range": (15, 120), # немного изменим
        "keywords_for_duration": {"совещание": (30,120), "планерка": (15,60), "one-on-one": (30,60)}
    },
    "обучение_развитие": {
        "actions": [
            "изучить {что_изучение}", "пройти онлайн-курс по {теме_курса}", "посмотреть вебинар о {чем_вебинар}",
            "почитать профессиональную литературу {какую_книгу}", "сделать упражнения по {предмету_упражнения}", "выучить новые слова на {языке_изучения}",
            "попрактиковаться в {навыке}", "посмотреть лекцию по {теме_лекции}"
        ],
        "duration_range": (30, 240), # расширим
        "keywords_for_duration": {"изучить": (40,150), "курс": (60,240), "лекцию": (45,120)}
    },
    "личные_дела_поручения": {
        "actions": [
            "записаться к {специалисту}", "оплатить {что_счета}", "сходить в {место_посещения}", "забрать {что_забрать} из {откуда_забрать}",
            "починить {что_ремонт}", "купить билеты на {событие}", "подать документы в {организацию}", "поздравить {кого} с {праздником}",
            "отвезти {что_отвезти} в {место_назначения}", "посетить {мероприятие_личного_характера}"
        ],
        "duration_range": (10, 120), # расширим
        "keywords_for_duration": {"записаться": (5,30), "оплатить счета": (10,40), "подать документы": (30,90)}
    },
    "отдых_хобби": {
        "actions": [
            "почитать книгу {какую_книгу_отдых}", "посмотреть фильм {какой_фильм}", "послушать {что_музыка}", "поиграть в {какую_игру}",
            "заняться хобби ({каким_хобби})", "погулять {где_прогулка}", "помедитировать", "поспать {сколько_сон} часов", "отдохнуть немного",
            "порисовать {что_рисование}", "поиграть на {муз_инструменте}"
        ],
        "duration_range": (20, 240), # расширим
        "keywords_for_duration": {"посмотреть фильм": (75,180), "погулять": (30,120), "поспать": (300, 600), "почитать книгу": (30,120)}
    },
    "спорт_здоровье": {
        "actions": [
            "сделать зарядку", "пойти на тренировку в {место_тренировки}", "пробежка на {дистанцию_бег}", "заняться йогой",
            "посетить врача {специалист_врач}", "принять лекарства", "сделать упражнения для {части_тела}", "поплавать в бассейне"
        ],
        "duration_range": (15, 150), # расширим
        "keywords_for_duration": {"тренировка": (40,100), "пробежка": (25,90), "врача": (30,90)}
    },
    "творчество_создание": {
        "actions": [
            "написать {что_текст}", "сочинить {что_музыкальное}", "сделать {что_рукоделие} своими руками",
            "записать видео о {теме_видео}", "разработать дизайн для {чего_дизайн}", "придумать идею для {проекта_идея}"
        ],
        "duration_range": (45, 300),
        "keywords_for_duration": {"написать текст": (60,240), "дизайн": (90,300), "видео": (120,360)}
    },
    "планирование_анализ_будущего": {
        "actions": [
            "спланировать {что_план_будущее}", "проанализировать {что_анализ_будущее}", "подумать над {вопросом_размышления}",
            "поставить цели на {период}", "обдумать стратегию {чего_стратегия}"
        ],
        "duration_range": (20, 120),
        "keywords_for_duration": {"спланировать": (30,90), "проанализировать": (45,120)}
    },
    "общие_задачи_с_новым_контекстом": { # Новая категория для использования ADDITIONAL_ACTIONS_CONTEXTS
        "actions": [
            "{глагол_общего_назначения} {объект_действия_разный}",
            "{глагол_общего_назначения} {объект_действия_разный} {контекст_места_инструмент}",
            "{глагол_общего_назначения} {объект_действия_разный} для {каким_проект}",
            "{глагол_общего_назначения} {объект_действия_разный} по {вопросу_коммуникации}",
            "быстро {глагол_общего_назначения} {объект_действия_разный}"
        ],
        "duration_range": (10, 180), # Широкий диапазон, т.к. действия разные
        "keywords_for_duration": {"проверить": (10,60), "подготовить": (30,120), "проанализировать": (45,180), "создать": (60,240)}
    }
}

# Заполнители для действий
PLACEHOLDERS = {
    "кому": ["маме", "другу", "коллеге", "начальнику", "клиенту", "подруге", "брату", "партнеру", "поставщику", "HR", "бухгалтеру", "аналитику", "разработчику", "менеджеру проекта", "дизайнеру"],
    "от кого": ["банка", "партнера", "руководства", "клиента", "коллеги", "друга", "отдела маркетинга", "технической поддержки", "заказчика", "пользователя"],
    "что": ["этот вопрос", "детали проекта", "план работ", "условия договора", "презентацию", "ужин", "отчет", "концепцию", "макет", "прототип", "спецификацию", "требования", "коммерческое предложение", "техническое задание"],
    "чем_покупки": ["хлебом", "молоком", "овощами", "фруктами", "необходимым", "бытовой химией", "канцтоварами", "кофе", "чаем", "вкусняшками к чаю", "лекарствами", "журналами"],
    "где_дом": ["комнате", "квартире", "на кухне", "в гостиной", "в ванной", "на балконе", "в кабинете", "в спальне", "в кладовке", "в гараже", "на чердаке"],
    "каким_проект": ["новым", "интересным", "сложным", "важным", "текущим", "личным", "рабочим", "благотворительным", "исследовательским"],
    "чего_программирование": ["новой фичи", "багфикса", "модуля", "скрипта", "интеграции", "API", "тестов", "оптимизации"],
    "что_программирование": ["программу", "скрипт", "алгоритм", "функцию", "класс", "веб-сервис", "мобильное приложение"],
    "теме_отчета": ["продаж", "нового продукта", "анализа конкурентов", "квартального отчета", "маркетинговой кампании", "эффективности рекламы", "посещаемости сайта", "финансовым результатам"],
    "чего_планирование": ["следующей недели", "маркетинговой кампании", "разработки фичи", "отпуска", "бюджета", "релиза", "переезда", "свадьбы"],
    "темы_исследования": ["рынка", "пользовательского поведения", "новых технологий", "эффективности процесса", "конкурентной среды", "целевой аудитории"],
    "какие_данные": ["финансовые", "статистические", "пользовательские", "операционные", "маркетинговые", "исторические", "прогнозные"],
    "чем_статья": ["искусственном интеллекте", "путешествиях", "здоровом питании", "новой технологии", "продуктивности", "финансах", "психологии"],
    "какую_задачу": ["сложную", "срочную", "аналитическую", "техническую", "креативную", "рутинную", "исследовательскую"],
    "кем_встреча": ["командой", "клиентом", "руководителем", "партнерами", "кандидатом", "инвестором", "подрядчиком"],
    "вопросу_созвона": ["сотрудничества", "поставки", "текущих задач", "обновлений", "фидбека", "стратегии", "проблем", "идей"],
    "тема_совещания": ["по итогам квартала", "по новому проекту", "о стратегии развития", "по проблемам в отделе", "мозговой штурм", "ретроспектива спринта"],
    "что_обсуждение": ["результаты спринта", "планы на следующий месяц", "возникшие проблемы", "новые идеи", "риски проекта", "требования заказчика"],
    "проекту_планерки": ["Alpha", "Omega", "развития платформы", "запуска продукта", "мобильного приложения", "веб-портала"],
    "что_изучение": ["новый фреймворк", "иностранный язык", "технику быстрого чтения", "основы дизайна", "методологию Agile", "язык программирования Go", "работу с Docker"],
    "теме_курса": ["Python-разработки", "маркетинга в соцсетях", "управления проектами", "финансовой грамотности", "машинного обучения", "анализа данных", "публичных выступлений"],
    "чем_вебинар": ["трендах в IT", "личной эффективности", "инвестициях", "копирайтинге", "нейросетях", "кибербезопасности"],
    "какую_книгу": ["по специальности", "художественную", "научно-популярную", "биографию", "по психологии", "по истории"],
    "предмету_упражнения": ["английскому языку", "программированию", "математике", "физике", "химии", "логике"],
    "языке_изучения": ["английском", "немецком", "испанском", "китайском", "французском", "японском", "итальянском"],
    "специалисту": ["врачу", "стоматологу", "парикмахеру", "юристу", "бухгалтеру", "психологу", "косметологу", "тренеру"],
    "что_счета": ["коммунальные услуги", "интернет", "мобильную связь", "кредит", "налоги", "штрафы", "подписки"],
    "место_посещения": ["банк", "почту", "химчистку", "спортзал", "бассейн", "МФЦ", "музей", "театр", "выставку", "библиотеку"],
    "что_забрать": ["посылку", "документы", "заказ", "одежду из химчистки", "ребенка из школы", "вещи из ремонта"],
    "откуда_забрать": ["ремонта", "прачечной", "пункта выдачи", "работы", "школы", "садика", "с почты", "у друга"],
    "что_ремонт": ["кран", "велосипед", "компьютер", "полку", "машину", "телефон", "одежду"],
    "событие": ["концерт", "спектакль", "футбольный матч", "самолет", "поезд", "вечеринку", "семинар", "конференцию"],
    "организацию": ["налоговую", "университет", "визовый центр", "банк", "страховую компанию", "госуслуги"],
    "праздником": ["днем рождения", "юбилеем", "Новым Годом", "профессиональным праздником", "годовщиной", "8 марта", "23 февраля"],
    "какую_книгу_отдых": ["детектив", "фантастику", "классику", "любовный роман", "триллер", "комиксы", "фэнтези"],
    "какой_фильм": ["новый", "документальный", "любимый", "комедию", "драму", "боевик", "мультфильм", "сериал"],
    "что_музыка": ["любимую музыку", "подкаст", "аудиокнигу", "новый альбом", "классическую музыку", "радио"],
    "какую_игру": ["компьютерную игру", "настолку", "шахматы", "головоломку", "карточную игру", "видеоигру на консоли"],
    "каким_хобби": ["вязанием", "моделированием", "фотографией", "садоводством", "кулинарией", "рисованием", "танцами", "коллекционированием"],
    "где_прогулка": ["в парке", "в лесу", "по городу", "вдоль набережной", "за городом", "в горах", "по пляжу"],
    "сколько_сон": ["7", "8", "немного", "час", "полтора", "6", "9"],
    "место_тренировки": ["спортзал", "стадион", "парк", "дом", "бассейн", "на улице", "фитнес-клуб"],
    "дистанцию_бег": ["5 км", "короткую дистанцию", "обычную дистанцию", "10 км", "интервальную", "марафонскую", "полумарафон"],
    "специалист_врач": ["терапевту", "окулисту", "кардиологу", "неврологу", "дерматологу", "ЛОРу", "эндокринологу"],
    "вопросу_коммуникации": ["проекту", "договору", "встрече", "отчету", "доставке", "оплате", "качеству", "срокам"],
    "что_еда": ["завтрак", "обед", "ужин", "пирог", "салат", "суп", "бутерброды", "десерт", "кашу"],
    "что_еда_заказ": ["пиццу", "суши", "готовую еду из ресторана", "продукты на дом", "бургеры", "пасту"],
    "что_разбор": ["вещи в шкафу", "старые бумаги", "фотографии", "инструменты", "книги", "игрушки", "электронику"],
    "носителе_информации": ["компьютере", "внешнем диске", "облаке", "флешке", "NAS", "сервере"],
    "что_чистка": ["раковину", "плиту", "микроволновку", "ковер", "окна", "духовку", "холодильник"],
    "чьего_кода": ["коллеги", "джуниора", "своего старого", "фрилансера", "команды разработки"],
    "системе": ["CRM", "базе данных", "API", "внутреннему порталу", "ERP-системе", "системе логирования", "платежной системе"],
    "тема_презентации": ["для клиента", "для команды", "по результатам проекта", "о новом продукте", "для инвесторов", "на конференции"],
    "навыке": ["слепой печати", "публичных выступлений", "быстрого счета", "рисования", "переговоров", "тайм-менеджмента"],
    "теме_лекции": ["истории искусств", "квантовой физике", "нейросетям", "экономике", "политологии", "философии"],
    "что_отвезти": ["документы", "подарок", "вещи", "заказ", "детей в школу", "кота к ветеринару"],
    "место_назначения": ["офис", "другу", "на дачу", "в сервис", "на почту", "в аэропорт"],
    "мероприятие_личного_характера": ["выставку", "родительское собрание", "встречу выпускников", "свадьбу друга", "день рождения родственника"],
    "что_рисование": ["пейзаж", "натюрморт", "портрет", "абстракцию", "эскиз", "иллюстрацию"],
    "муз_инструменте": ["гитаре", "пианино", "скрипке", "барабанах", "флейте", "саксофоне"],
    "части_тела": ["спины", "пресса", "ног", "рук", "плеч", "шеи"],
    "что_текст": ["статью для блога", "рассказ", "стихотворение", "пост для соцсетей", "сценарий", "рекламный текст", "письмо"],
    "что_музыкальное": ["песню", "мелодию", "аранжировку", "бит", "саундтрек"],
    "что_рукоделие": ["шарф", "игрушку", "картину", "украшение", "мыло", "свечу", "одежду"],
    "теме_видео": ["обзоре продукта", "путешествии", "обучающем материале", "интервью", "влоге"],
    "чего_дизайн": ["сайта", "логотипа", "интерьера", "приложения", "рекламного баннера", "упаковки", "персонажа"],
    "проекта_идея": ["стартапа", "нового продукта", "улучшения процесса", "творческого проекта", "социальной инициативы", "мобильного приложения"],
    "что_план_будущее": ["карьеру", "путешествие", "покупку", "обучение", "ремонт", "инвестиции"],
    "что_анализ_будущее": ["свои финансы", "прошлые ошибки", "возможности для роста", "риски", "тенденции рынка", "конкурентов"],
    "вопросом_размышления": ["смысле жизни", "будущем", "принятии решения", "своих целях", "новых возможностях", "проблеме выбора"],
    "период": ["неделю", "месяц", "квартал", "год", "пятилетку", "ближайшие пару дней", "следующий год"],
    "чего_стратегия": ["развития бизнеса", "личного бренда", "инвестирования", "достижения цели", "продвижения продукта", "обучения"],
    # Добавляем плейсхолдеры для новой категории
    "глагол_общего_назначения": ADDITIONAL_ACTIONS_CONTEXTS["глаголы_общего_назначения"],
    "объект_действия_разный": ADDITIONAL_ACTIONS_CONTEXTS["объекты_действий_разные"],
    "контекст_места_инструмент": ADDITIONAL_ACTIONS_CONTEXTS["контексты_места_инструменты"]
}


HIGH_PRIORITY_KEYWORDS = [
    "срочно", "важно", "немедленно", "в первую очередь", "обязательно", "критично", "дедлайн", "горит",
    "кровь из носу", "экстренно", "безотлагательно", "крайний срок", "must have", "top priority", "первоочередно",
    "требует немедленного внимания", "сделать сегодня", "заблокировано до выполнения"
]
LOW_PRIORITY_KEYWORDS = [
    "если будет время", "потом", "не горит", "можно отложить", "второстепенно", "когда-нибудь", "не к спеху",
    "по возможности", "опционально", "позже", "nice to have", "low priority", "в свободное время",
    "если останутся силы", "можно сделать на следующей неделе", "не критично"
]

# Дополнительные ключевые слова для длительности, специфичные для категорий
TASK_CATEGORIES["короткие_коммуникации"]["keywords_for_duration"].update({
    "быстро ответить": (2, 10), "уточнить": (5, 15)
})
TASK_CATEGORIES["работа_проекты"]["keywords_for_duration"].update({
    "написать код": (60, 300), "отладить": (30, 180), "ревью кода": (30, 90), "документац": (45, 180)
})
TASK_CATEGORIES["встречи_созвоны"]["keywords_for_duration"].update({
    "стендап": (10,20), "daily митинг": (10,25)
})
TASK_CATEGORIES["обучение_развитие"]["keywords_for_duration"].update({
    "посмотреть вебинар": (45, 120), "пройти урок": (30, 90)
})


def get_realistic_duration(action_text_template, action_text_concrete):
    action_text_lower = action_text_concrete.lower()

    # Сначала ищем по ключевым словам в конкретной фразе, если они есть в категории
    for category_name, cat_data in TASK_CATEGORIES.items():
        if action_text_template in cat_data["actions"]: # Проверяем, что шаблон из этой категории
            for keyword, (dur_min, dur_max) in cat_data.get("keywords_for_duration", {}).items():
                if keyword in action_text_lower:
                    return random.randint(dur_min // 5, dur_max // 5) * 5 # Возвращаем с шагом 5 минут
            # Если специфичных ключевых слов не найдено, используем общий диапазон категории
            cat_min, cat_max = cat_data["duration_range"]
            return random.randint(cat_min // 5, cat_max // 5) * 5

    # Общий дефолт, если категория не найдена (маловероятно при текущей логике)
    return random.choice([30, 45, 60, 90])


def determine_priority(action_text_template, action_text_concrete, explicit_priority_phrase=None):
    action_text_concrete_lower = action_text_concrete.lower()
    # high: 2, medium: 1, low: 0

    # 1. Явные фразы приоритета
    if explicit_priority_phrase:
        phrase_lower = explicit_priority_phrase.lower()
        if any(k in phrase_lower for k in HIGH_PRIORITY_KEYWORDS):
            return 2 # high
        if any(k in phrase_lower for k in LOW_PRIORITY_KEYWORDS):
            return 0 # low

    # 2. Ключевые слова в самом тексте задачи
    if any(k in action_text_concrete_lower for k in HIGH_PRIORITY_KEYWORDS):
        return 2 # high
    if any(k in action_text_concrete_lower for k in LOW_PRIORITY_KEYWORDS):
        return 0 # low

    # 3. Эвристики на основе категории задачи
    category_name = None
    for cat_name, cat_data in TASK_CATEGORIES.items():
        if action_text_template in cat_data["actions"]:
            category_name = cat_name
            break

    if category_name:
        if category_name in ["работа_проекты", "встречи_созвоны"]:
            # Для рабочих задач и встреч, если нет других указаний, шанс на высокий/средний приоритет выше
            if random.random() < 0.4: return 2 # 40% шанс на высокий
            if random.random() < 0.7: return 1 # Еще 30% (от оставшихся 60%) на средний (итого ~42% на средний)
            # остальное на низкий (редко для таких категорий без явных слов)
        elif category_name in ["личные_дела_поручения", "спорт_здоровье", "творчество_создание", "планирование_анализ_будущего"]:
             # Эти категории могут быть как важными, так и не очень
            if random.random() < 0.2: return 2 # 20% высокий
            if random.random() < 0.6: return 1 # ~48% средний (0.8 * 0.6)
            return 0 # остальное низкий
        elif category_name in ["отдых_хобби", "быт_еда", "уборка_организация"]:
            # Эти категории чаще имеют низкий или средний приоритет
            if random.random() < 0.1: return 2 # 10% высокий (редко)
            if random.random() < 0.5: return 1 # ~45% средний
            return 0 # остальное низкий
        elif category_name == "короткие_коммуникации":
            if any(kw in action_text_concrete_lower for kw in ["согласовать", "уточнить детали"]):
                return random.choice([1,2]) # Средний или высокий
            return random.choice([0,1]) # Низкий или средний
        elif category_name == "общие_задачи_с_новым_контекстом":
            # Здесь сложнее, зависит от конкретных слов. Дадим смещение к среднему.
            if any(kw in action_text_concrete_lower for kw in ["отчет", "презентац", "документ", "дедлайн", "срочная задача", "проект", "клиент"]):
                return random.choice([1,2])
            return random.choice([0, 1, 1]) # Смещение к среднему

    # 4. Общие ключевые слова (если категория не помогла или для общих случаев)
    if any(kw in action_text_concrete_lower for kw in ["отчет", "презентац", "документ", "дедлайн", "срочная задача", "клиент", "договор", "баг", "исправить ошибку", "проблема"]):
        return 2 # high
    if any(kw in action_text_concrete_lower for kw in ["посмотреть фильм", "почитать книгу", "погулять", "отдохнуть", "хобби", "поиграть", "развлечение"]):
        return 0 # low

    # 5. По умолчанию, если ничего не подошло
    return 1 # medium


def generate_task_item():
    # Выбираем случайную категорию и из нее случайный шаблон действия
    chosen_category_name = random.choice(list(TASK_CATEGORIES.keys()))
    chosen_category = TASK_CATEGORIES[chosen_category_name]
    action_template = random.choice(chosen_category["actions"])

    # Заполняем плейсхолдеры в шаблоне действия
    action_text_concrete = action_template
    # Ищем все плейсхолдеры вида {key}
    placeholders_in_template = [ph[1:-1] for ph in action_template.split() if ph.startswith("{") and ph.endswith("}")]

    filled_placeholders = {}
    for ph_key in placeholders_in_template:
        if ph_key in PLACEHOLDERS:
            chosen_value = random.choice(PLACEHOLDERS[ph_key])
            action_text_concrete = action_text_concrete.replace("{" + ph_key + "}", chosen_value, 1)
            filled_placeholders[ph_key] = chosen_value

    # Временные указания и соответствующие минуты
    # Расширенный список, включающий более разнообразные и числовые варианты
    time_options = [
        ("часик", 60), ("пару часов", 120), ("полчаса", 30), ("часа полтора", 90), ("полтора часа", 90),
        ("два часа", 120), ("три часа", 180), ("четыре часа", 240), ("пять часов", 300), ("шесть часов", 360),
        ("минут 5", 5), ("минут 10", 10), ("минут 15", 15), ("минут 20", 20), ("минут 25", 25),
        ("минут 30", 30), ("минут 40", 40), ("минут 45", 45), ("минут 50", 50), ("минут 55", 55), ("минут 75", 75), ("минут 90", 90),
        ("1 час", 60), ("2 часа", 120), ("3 часа", 180), ("4 часа", 240), ("5 часов", 300),
        ("1.5 часа", 90), ("2.5 часа", 150), ("0.5 часа", 30), ("3.5 часа", 210),
        ("1ч", 60), ("2ч", 120), ("1ч30м", 90), ("45м", 45), ("90 мин", 90), ("15 мин", 15), ("120 минут", 120), ("180 минут", 180),
        ("на полчасика", 30), ("на часок-другой", random.choice([60, 90, 120, 150])), ("на пару-тройку часов", random.choice([120, 150, 180, 210])),
        ("немного времени на", random.choice([15, 20, 30, 40, 50])),
        ("посвятить этому где-то", random.choice([45, 60, 75, 90, 100, 120, 150])),
        ("займет примерно", random.choice([20, 25, 35, 40, 50, 70, 80, 100])), # Добавлено
        ("буквально {N} минут", None), # Динамическое значение N
        ("около {N} часов", None), # Динамическое значение N
        ("примерно {N} мин.", None), # Динамическое значение N
        ("где-то {N} ч.", None), # Динамическое значение N
        ("", None) # Вариант без явного указания времени (будет использован get_realistic_duration)
    ]
    
    # Вероятность явного указания времени (например, 80%)
    has_explicit_duration_phrase = False
    if random.random() < 0.80: # Увеличена вероятность явного указания времени
        duration_phrase_template, duration_minutes_from_phrase = random.choice(time_options)

        # Обработка динамических фраз
        if "{N}" in duration_phrase_template:
            if "минут" in duration_phrase_template or "мин." in duration_phrase_template:
                n_val = random.choice([5, 10, 15, 20, 25, 30, 40, 45, 50, 60, 75, 90])
                actual_duration_minutes = n_val
                duration_phrase = duration_phrase_template.format(N=n_val)
                has_explicit_duration_phrase = True
            elif "часов" in duration_phrase_template or "ч." in duration_phrase_template:
                n_val = random.choice([1, 2, 3, 4, 1.5, 2.5, 0.5])
                actual_duration_minutes = int(n_val * 60)
                duration_phrase = duration_phrase_template.format(N=str(n_val).replace('.5', ',5')) # для "1,5 часа"
                has_explicit_duration_phrase = True
            else: # на всякий случай, если шаблон другой
                actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)
                duration_phrase = ""
                # has_explicit_duration_phrase remains False
        elif duration_minutes_from_phrase is None: # Если выбран вариант "без явного указания времени"
            actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)
            duration_phrase = "" # Убедимся, что фраза пустая
            # has_explicit_duration_phrase remains False
        else:
            actual_duration_minutes = duration_minutes_from_phrase
            duration_phrase = duration_phrase_template
            if duration_phrase.strip(): # Если фраза не пустая
                has_explicit_duration_phrase = True
            # Небольшая вариативность для фраз типа "часик", "пару часов"
            if duration_phrase_template in ["часик", "пару часов", "на часок-другой", "на пару-тройку часов"]:
                 # Делаем так, чтобы actual_duration_minutes всегда был кратен 5
                 min_val = max(15, actual_duration_minutes - 30)
                 max_val = actual_duration_minutes + 30
                 actual_duration_minutes = random.randint(min_val // 5, max_val // 5) * 5
    else:
        duration_phrase = ""
        actual_duration_minutes = get_realistic_duration(action_template, action_text_concrete)
        # has_explicit_duration_phrase remains False

    # Фразы приоритета
    priority_phrases = ["", "это очень важно", "нужно сделать срочно", "это не горит", "можно сделать потом",
                        "обязательно выполни", "критически важно", "если останется время", "первостепенно",
                        "не к спеху", "сделай как можно скорее", "постарайся успеть", "второстепенная задача",
                        "это прям горит", "подождет до завтра", "это приоритетно", "сделай это в первую очередь",
                        "не забудь, это важно", "можно не спешить с этим", "пока не трогай", "отложи на потом"]

    # Вероятность явного указания приоритета фразой (например, 60%)
    explicit_priority_phrase = ""
    if random.random() < 0.6: # Увеличена вероятность
        explicit_priority_phrase = random.choice(priority_phrases)

    priority = determine_priority(action_template, action_text_concrete, explicit_priority_phrase)

    # Убедимся, что текст задачи не пустой, если плейсхолдеры не заполнились (маловероятно)
    if not action_text_concrete.strip():
        action_text_concrete = "какое-то дело" # Запасной вариант

    return action_text_concrete, duration_phrase, actual_duration_minutes, priority, explicit_priority_phrase, has_explicit_duration_phrase


def generate_freeform_sentence():
    starters = [
        "Сегодня мне нужно", "Мой план на день:", "Надо не забыть", "Запланировал себе",
        "Вот что я должен сделать:", "Задачи на сегодня:", "Хочу успеть", "Собираюсь сделать",
        "Мои дела:", "Планы:", "Необходимо выполнить:", "Список дел:", "Так, поехали:",
        "На повестке дня:", "Сегодня в программе:", "Первым делом,",
        "Итак, что у нас тут:", "Нужно быстренько:", "Сфокусируюсь на:" # Новые стартеры
    ]
    
    # Шаблоны для сборки предложения с задачей
    # {action} - сама задача
    # {duration_phrase} - фраза о времени, например "полчаса"
    # {priority_phrase} - фраза о приоритете, например "это очень важно"
    sentence_templates = [
        "{action} {duration_phrase} {priority_phrase}",
        "{action} {priority_phrase} {duration_phrase}",
        "{priority_phrase}, {action} {duration_phrase}",
        "{action} {duration_phrase}",
        "{action} {priority_phrase}",
        "{action}",
        "{duration_phrase} на {action} {priority_phrase}",
        "{duration_phrase} хочу потратить на {action}",
        "Займусь {action} {duration_phrase}",
        "Нужно {action}", "Надо бы {action}",
        "Обязательно {action} {duration_phrase}",
        "Не забыть: {action}",
        "Потом можно {action}",
        "Если успею, то {action} {duration_phrase}",
        "В планах также {action}",
        "Кстати, еще {action} {priority_phrase}",
        "И {action} {duration_phrase} {priority_phrase}.", # Добавил точку для разнообразия
        "Не забыть бы про {action}.",
        "Еще одна вещь: {action} {priority_phrase}",
        "Также {action} {duration_phrase}",
        "Надо {action}, {priority_phrase}, займет {duration_phrase}" # Новые шаблоны
    ]
    
    full_text = random.choice(starters) + " "
    num_tasks = random.randint(1, 7) # Увеличим максимальное число задач до 7
    entities = []
    current_pos = len(full_text)

    for i in range(num_tasks):
        action_text_concrete, duration_ph, duration_min, task_priority, priority_ph, has_expl_dur_ph = generate_task_item()
        
        # Выбираем шаблон для текущей задачи
        template = random.choice(sentence_templates)
        
        # Подготавливаем части для форматирования
        format_args = {
            "action": action_text_concrete, # Используем конкретный текст задачи
            "duration_phrase": duration_ph.strip(),
            "priority_phrase": priority_ph.strip()
        }
        
        # Собираем полный текст текущего элемента списка дел
        # Убираем лишние пробелы, которые могли возникнуть из-за пустых фраз
        current_task_full_phrase = template.format(**format_args)
        current_task_full_phrase = ' '.join(filter(None, current_task_full_phrase.split(' ')))
        current_task_full_phrase = current_task_full_phrase.replace(" ,", ",").replace(" .", ".") # Чистим пунктуацию
        
        # Добавляем в общий текст
        full_text += current_task_full_phrase

        # Определяем start/end для action_text_concrete
        # Ищем action_text_concrete в только что добавленном current_task_full_phrase
        action_start_in_segment = -1
        # Пробуем найти точное совпадение сначала
        # Для более надежного поиска можно использовать fuzzy matching или учитывать возможные вариации из-за форматирования
        # но для генерации, где мы контролируем процесс, это должно работать нормально.

        # Чтобы поиск был точнее, мы ищем action_text_concrete в последнем добавленном сегменте (current_task_full_phrase)
        # и затем смещаем на current_pos.
        # Однако, если action_text_concrete сам является результатом форматирования (например, содержит duration_phrase),
        # то лучше искать его "как есть".

        # Ищем action_text_concrete в full_text, начиная с current_pos.
        # Это более надежно, если action_text_concrete не содержит других фраз.
        # Если action_text_concrete может содержать duration_phrase или priority_phrase (из-за шаблона),
        # то нужно извлекать "чистую" задачу. Для простоты, сейчас считаем, что action_text_concrete - это и есть задача.

        search_text_lower = full_text[current_pos:].lower()
        action_to_find_lower = action_text_concrete.lower()

        action_start_in_segment = search_text_lower.find(action_to_find_lower)

        if action_start_in_segment != -1:
            action_start_global = current_pos + action_start_in_segment
            action_end_global = action_start_global + len(action_text_concrete) # Длина оригинального, не lower-case

            # Проверка на пересечение с предыдущими сущностями (простой вариант)
            valid_entity = True
            for prev_entity in entities:
                if max(prev_entity['start'], action_start_global) < min(prev_entity['end'], action_end_global):
                    valid_entity = False
                    # print(f"Warning: Overlapping entity found for '{action_text_concrete}'. Skipping.") # Для отладки
                    break

            if valid_entity:
                entities.append({
                    "text": action_text_concrete, # Текст самой задачи
                    "start": action_start_global,
                    "end": action_end_global,
                    "label": "TASK",
                    "priority": task_priority,
                    "duration_minutes": duration_min,
                    "duration_phrase_original": duration_ph,
                    "has_explicit_duration_phrase": has_expl_dur_ph
                })

        current_pos += len(current_task_full_phrase)

        # Добавление разделителей
        if i < num_tasks - 1:
            # Добавляем больше вариаций разделителей и опционально точку перед следующим элементом
            if random.random() < 0.2 and not full_text.strip().endswith((".", "!", "?", ";", ",")):
                full_text += random.choice([". ", "! ", "? "]) # Завершаем предыдущее "предложение"
                current_pos += 2
                # Иногда начинаем следующее "предложение" с заглавной буквы (имитация)
                # Это не меняет сами токены, но может влиять на контекст для NER
                if random.random() < 0.5:
                     current_task_full_phrase = current_task_full_phrase[0].upper() + current_task_full_phrase[1:]

            sep = random.choice([", ", "; ", ". Потом ", ". А еще ", " и ", ". Затем ", ". После этого ",
                                 ", также ", ", кроме того ", ". Далее, ", " плюс к этому "])
            full_text += sep
            current_pos += len(sep)
        else:
            # Убедимся, что в конце есть знак препинания, если его еще нет
            if not full_text.strip().endswith((".", "!", "?")):
                 full_text += random.choice([".", "!"])
                 current_pos += 1
            elif full_text.strip().endswith((",", ";")): # Заменяем висящие запятые/точки с запятой
                full_text = full_text.strip()[:-1] + random.choice([".", "!"])


    # Финальная очистка текста (убрать лишние пробелы по краям, двойные пробелы, пробелы перед знаками препинания)
    full_text = ' '.join(full_text.split())
    full_text = full_text.replace(" .", ".").replace(" ,", ",").replace(" !", "!").replace(" ?", "?")
    full_text = full_text.replace(" ;", ";")


    return {
        "text": full_text,
        "entities": entities # Отдаем только непересекающиеся сущности
    }

# Генерация датасета
NUM_EXAMPLES = 5000 # Увеличено количество примеров
dataset = []
generated_count = 0
# Увеличим attempt_limit пропорционально, и добавим еще запас, т.к. генерация может быть сложнее
attempt_limit = NUM_EXAMPLES * 5

while generated_count < NUM_EXAMPLES and attempt_limit > 0:
    example = generate_freeform_sentence()
    # Проверяем, что есть хотя бы одна сущность, чтобы избежать пустых примеров
    # и что текст не слишком короткий (например, минимум 10 символов)
    # И что есть хотя бы одна задача с явным указанием длительности и одна с явным приоритетом (для баланса)
    # Это условие может быть слишком строгим, но попробуем для улучшения качества.
    # Если будет генерироваться мало данных, можно ослабить.
    has_explicit_duration_task = any(e.get('has_explicit_duration_phrase', False) for e in example["entities"])
    # has_explicit_priority_task = any(e.get('priority_phrase_original', "") != "" for e in example["entities"]) # Это не совсем то, priority_phrase_original может быть пустой, но приоритет определен

    # Проверим, что хотя бы одна задача имеет не средний (1) приоритет, если генерируется фраза приоритета
    # или что есть задачи с высоким и низким приоритетом в целом.
    # Лучше ориентироваться на разнообразие приоритетов в целом в примере.
    priorities_in_example = {e['priority'] for e in example["entities"]}
    has_varied_priorities = len(priorities_in_example) > 1 or (1 not in priorities_in_example and len(priorities_in_example) > 0)


    if example["entities"] and len(example["text"]) > 10 and has_explicit_duration_task and has_varied_priorities:
        dataset.append(example)
        generated_count += 1
    elif example["entities"] and len(example["text"]) > 10 and random.random() < 0.3: # 30% шанс добавить, даже если условия не идеальны, но базовые (сущности и длина) соблюдены
        dataset.append(example)
        generated_count += 1

    attempt_limit -=1

if generated_count < NUM_EXAMPLES:
    if attempt_limit <= 0:
        print(f"Предупреждение: Достигнут лимит попыток генерации. Сгенерировано {generated_count} из {NUM_EXAMPLES} примеров.")
    else: # Сюда мы не должны попасть, если generated_count < NUM_EXAMPLES, т.к. цикл бы продолжался, если attempt_limit > 0
        print(f"Предупреждение: Сгенерировано только {generated_count} из {NUM_EXAMPLES} запрошенных примеров (несмотря на оставшиеся попытки).")
elif generated_count == 0 and NUM_EXAMPLES > 0 :
     print(f"ОШИБКА: Не сгенерировано ни одного примера. Проверьте условия отбора в цикле генерации.")


# Сохранение
output_file_path = 'ml/freeform_task_dataset.json'
with open(output_file_path, 'w', encoding='utf-8') as f:
    json.dump(dataset, f, ensure_ascii=False, indent=2)

print(f"Создан датасет ({len(dataset)} примеров) и сохранен в '{output_file_path}'.")

# Пример вывода одного элемента
if dataset:
    print("\nПример сгенерированного элемента:")
    print(json.dumps(dataset[0], ensure_ascii=False, indent=2))
else:
    print("\nНе удалось сгенерировать ни одного элемента для датасета.")
